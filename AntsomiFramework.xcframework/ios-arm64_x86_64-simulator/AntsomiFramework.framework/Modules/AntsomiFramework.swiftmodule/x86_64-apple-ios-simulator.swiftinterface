// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.2 effective-5.10 (swiftlang-6.0.2.1.2 clang-1600.0.26.4)
// swift-module-flags: -target x86_64-apple-ios10.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-bare-slash-regex -module-name AntsomiFramework
// swift-module-flags-ignorable: -no-verify-emitted-module-interface
@_exported import AntsomiFramework
import CommonCrypto
import CommonCrypto/*.CC_LONG*/
import CommonCrypto/*.CC_MD5*/
import CommonCrypto/*.CC_MD5_DIGEST_LENGTH*/
import Dispatch
import Foundation
import Network
import Security
import Swift
import SystemConfiguration
import UIKit
import UserNotifications
import UserNotificationsUI
import WebKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import zlib
public protocol SocketIOClientSpec : AnyObject {
  var anyHandler: ((SocketAnyEvent) -> ())? { get }
  var handlers: [SocketEventHandler] { get }
  var manager: (any SocketManagerSpec)? { get }
  var nsp: Swift.String { get }
  var rawEmitView: SocketRawView { get }
  var sid: Swift.String? { get }
  var status: SocketIOStatus { get }
  func connect(withPayload payload: [Swift.String : Any]?)
  func connect(withPayload payload: [Swift.String : Any]?, timeoutAfter: Swift.Double, withHandler handler: (() -> ())?)
  func didConnect(toNamespace namespace: Swift.String, payload: [Swift.String : Any]?)
  func didDisconnect(reason: Swift.String)
  func didError(reason: Swift.String)
  func disconnect()
  func emit(_ event: Swift.String, _ items: any SocketData..., completion: (() -> ())?)
  func emit(_ event: Swift.String, with items: [any SocketData], completion: (() -> ())?)
  func emitAck(_ ack: Swift.Int, with items: [Any])
  func emitWithAck(_ event: Swift.String, _ items: any SocketData...) -> OnAckCallback
  func emitWithAck(_ event: Swift.String, with items: [any SocketData]) -> OnAckCallback
  func handleAck(_ ack: Swift.Int, data: [Any])
  func handleClientEvent(_ event: SocketClientEvent, data: [Any])
  func handleEvent(_ event: Swift.String, data: [Any], isInternalMessage: Swift.Bool, withAck ack: Swift.Int)
  func handlePacket(_ packet: SocketPacket)
  func leaveNamespace()
  func joinNamespace(withPayload payload: [Swift.String : Any]?)
  func off(clientEvent event: SocketClientEvent)
  func off(_ event: Swift.String)
  func off(id: Foundation.UUID)
  func on(_ event: Swift.String, callback: @escaping NormalCallback) -> Foundation.UUID
  func on(clientEvent event: SocketClientEvent, callback: @escaping NormalCallback) -> Foundation.UUID
  func once(clientEvent event: SocketClientEvent, callback: @escaping NormalCallback) -> Foundation.UUID
  func once(_ event: Swift.String, callback: @escaping NormalCallback) -> Foundation.UUID
  func onAny(_ handler: @escaping (SocketAnyEvent) -> ())
  func removeAllHandlers()
  func setReconnecting(reason: Swift.String)
}
extension SocketIOClientSpec {
  public func didError(reason: Swift.String)
}
public enum SocketClientEvent : Swift.String {
  case connect
  case disconnect
  case error
  case ping
  case pong
  case reconnect
  case reconnectAttempt
  case statusChange
  case websocketUpgrade
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@objc final public class SocketAckEmitter : ObjectiveC.NSObject {
  @objc final public var rawEmitView: SocketRawAckView {
    @objc get
  }
  final public var expected: Swift.Bool {
    get
  }
  public init(socket: SocketIOClient, ackNum: Swift.Int)
  final public func with(_ items: any SocketData...)
  @objc final public func with(_ items: [Any])
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers final public class OnAckCallback : ObjectiveC.NSObject {
  @objc deinit
  @objc final public func timingOut(after seconds: Swift.Double, callback: @escaping AckCallback)
}
public class StringHTTPHandler : HTTPHandler {
  public init()
  public func convert(request: Foundation.URLRequest) -> Foundation.Data
  public func parse(data: Foundation.Data) -> Swift.Int
  public func register(delegate: any HTTPHandlerDelegate)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers open class AntsomiNotificationService : UserNotifications.UNNotificationServiceExtension, UserNotifications.UNUserNotificationCenterDelegate {
  open var appGroupsId: Swift.String? {
    get
  }
  @objc override dynamic open func didReceive(_ request: UserNotifications.UNNotificationRequest, withContentHandler contentHandler: @escaping (UserNotifications.UNNotificationContent) -> Swift.Void)
  @objc override dynamic open func serviceExtensionTimeWillExpire()
  @objc override dynamic public init()
  @objc deinit
}
public class WSEngine : Engine, TransportEventClient, FramerEventClient, FrameCollectorDelegate, HTTPHandlerDelegate {
  public var respondToPingWithPong: Swift.Bool
  public init(transport: any Transport, certPinner: (any CertificatePinning)? = nil, headerValidator: any HeaderValidator = FoundationSecurity(), httpHandler: any HTTPHandler = FoundationHTTPHandler(), framer: any Framer = WSFramer(), compressionHandler: (any CompressionHandler)? = nil)
  public func register(delegate: any EngineDelegate)
  public func start(request: Foundation.URLRequest)
  public func stop(closeCode: Swift.UInt16 = CloseCode.normal.rawValue)
  public func forceStop()
  public func write(string: Swift.String, completion: (() -> ())?)
  public func write(data: Foundation.Data, opcode: FrameOpCode, completion: (() -> ())?)
  public func connectionChanged(state: ConnectionState)
  public func didReceiveHTTP(event: HTTPEvent)
  public func frameProcessed(event: FrameEvent)
  public func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
  public func didForm(event: FrameCollector.Event)
  @objc deinit
}
public struct SocketIOClientConfiguration : Swift.ExpressibleByArrayLiteral, Swift.Collection, Swift.MutableCollection {
  public typealias Element = SocketIOClientOption
  public typealias Index = Swift.Array<SocketIOClientOption>.Index
  public typealias Iterator = Swift.Array<SocketIOClientOption>.Iterator
  public typealias SubSequence = Swift.Array<SocketIOClientOption>.SubSequence
  public var startIndex: SocketIOClientConfiguration.Index {
    get
  }
  public var endIndex: SocketIOClientConfiguration.Index {
    get
  }
  public var isEmpty: Swift.Bool {
    get
  }
  public var count: SocketIOClientConfiguration.Index.Stride {
    get
  }
  public var first: SocketIOClientConfiguration.Element? {
    get
  }
  public subscript(position: SocketIOClientConfiguration.Index) -> SocketIOClientConfiguration.Element {
    get
    set
  }
  public subscript(bounds: Swift.Range<SocketIOClientConfiguration.Index>) -> SocketIOClientConfiguration.SubSequence {
    get
    set
  }
  public init(arrayLiteral elements: SocketIOClientConfiguration.Element...)
  public func makeIterator() -> SocketIOClientConfiguration.Iterator
  public func index(after i: SocketIOClientConfiguration.Index) -> SocketIOClientConfiguration.Index
  public mutating func insert(_ element: SocketIOClientConfiguration.Element, replacing replace: Swift.Bool = true)
  public typealias ArrayLiteralElement = SocketIOClientConfiguration.Element
  public typealias Indices = Swift.DefaultIndices<SocketIOClientConfiguration>
}
public protocol ConfigSettable {
  mutating func setConfigs(_ config: SocketIOClientConfiguration)
}
@objc open class SocketEngine : ObjectiveC.NSObject, WebSocketDelegate, Foundation.URLSessionDelegate, SocketEnginePollable, SocketEngineWebsocket, ConfigSettable {
  final public let engineQueue: Dispatch.DispatchQueue
  public var connectParams: [Swift.String : Any]? {
    get
    set
  }
  public var extraHeaders: [Swift.String : Swift.String]?
  public var postWait: [Post]
  public var waitingForPoll: Swift.Bool
  public var waitingForPost: Swift.Bool
  public var closed: Swift.Bool {
    get
  }
  public var compress: Swift.Bool {
    get
  }
  public var connected: Swift.Bool {
    get
  }
  public var cookies: [Foundation.HTTPCookie]? {
    get
  }
  public var fastUpgrade: Swift.Bool {
    get
  }
  public var forcePolling: Swift.Bool {
    get
  }
  public var forceWebsockets: Swift.Bool {
    get
  }
  public var invalidated: Swift.Bool {
    get
  }
  public var polling: Swift.Bool {
    get
  }
  public var probing: Swift.Bool {
    get
  }
  public var session: Foundation.URLSession? {
    get
  }
  public var sid: Swift.String {
    get
  }
  public var socketPath: Swift.String {
    get
  }
  public var urlPolling: Foundation.URL {
    get
  }
  public var urlWebSocket: Foundation.URL {
    get
  }
  public var useCustomEngine: Swift.Bool {
    get
  }
  public var version: SocketIOVersion {
    get
  }
  @available(*, deprecated, message: "No longer needed, if we're not polling, then we must be doing websockets")
  public var websocket: Swift.Bool {
    get
  }
  public var enableSOCKSProxy: Swift.Bool {
    get
  }
  public var ws: WebSocket? {
    get
  }
  public var wsConnected: Swift.Bool {
    get
  }
  weak public var client: (any SocketEngineClient)?
  public init(client: any SocketEngineClient, url: Foundation.URL, config: SocketIOClientConfiguration)
  required convenience public init(client: any SocketEngineClient, url: Foundation.URL, options: [Swift.String : Any]?)
  @objc deinit
  open func connect()
  open func didError(reason: Swift.String)
  open func disconnect(reason: Swift.String)
  open func doFastUpgrade()
  open func flushWaitingForPostToWebSocket()
  open func parseEngineData(_ data: Foundation.Data)
  open func parseEngineMessage(_ message: Swift.String)
  open func setConfigs(_ config: SocketIOClientConfiguration)
  open func write(_ msg: Swift.String, withType type: SocketEnginePacketType, withData data: [Foundation.Data], completion: (() -> ())? = nil)
}
extension SocketEngine {
  public func URLSession(session: Foundation.URLSession, didBecomeInvalidWithError error: Foundation.NSError?)
}
extension SocketEngine {
  public func didReceive(event: WebSocketEvent, client: any WebSocketClient)
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
@available(watchOS, unavailable)
public class WebSocketServer : Server, ConnectionDelegate {
  public var onEvent: ((ServerEvent) -> Swift.Void)?
  public init()
  public func start(address: Swift.String, port: Swift.UInt16) -> (any Swift.Error)?
  public func didReceive(event: ServerEvent)
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
public class ServerConnection : Connection, HTTPServerDelegate, FramerEventClient, FrameCollectorDelegate, TransportEventClient {
  public var onEvent: ((ConnectionEvent) -> Swift.Void)?
  weak public var delegate: (any ConnectionDelegate)?
  public func write(data: Foundation.Data, opcode: FrameOpCode)
  public func connectionChanged(state: ConnectionState)
  public func didReceive(event: HTTPEvent)
  public func frameProcessed(event: FrameEvent)
  public func didForm(event: FrameCollector.Event)
  public func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
  @objc deinit
}
@objc open class SocketManager : ObjectiveC.NSObject, SocketManagerSpec, SocketParsable, SocketDataBufferable, ConfigSettable {
  public var defaultSocket: SocketIOClient {
    get
  }
  final public let socketURL: Foundation.URL
  public var config: SocketIOClientConfiguration {
    get
    set
  }
  public var engine: (any SocketEngineSpec)?
  public var forceNew: Swift.Bool
  public var handleQueue: Dispatch.DispatchQueue
  public var nsps: [Swift.String : SocketIOClient]
  public var reconnects: Swift.Bool
  public var reconnectWait: Swift.Int
  public var reconnectWaitMax: Swift.Int
  public var randomizationFactor: Swift.Double
  public var status: SocketIOStatus {
    get
  }
  public var version: SocketIOVersion {
    get
  }
  public var waitingPackets: [SocketPacket]
  public init(socketURL: Foundation.URL, config: SocketIOClientConfiguration = [])
  @objc convenience public init(socketURL: Foundation.URL, config: [Swift.String : Any]?)
  @objc deinit
  open func connect()
  open func connectSocket(_ socket: SocketIOClient, withPayload payload: [Swift.String : Any]? = nil)
  open func didDisconnect(reason: Swift.String)
  open func disconnect()
  open func disconnectSocket(_ socket: SocketIOClient)
  open func disconnectSocket(forNamespace nsp: Swift.String)
  open func emitAll(clientEvent event: SocketClientEvent, data: [Any])
  open func emitAll(_ event: Swift.String, _ items: any SocketData...)
  @objc open func engineDidClose(reason: Swift.String)
  @objc open func engineDidError(reason: Swift.String)
  @objc open func engineDidOpen(reason: Swift.String)
  @objc open func engineDidReceivePing()
  @objc open func engineDidSendPing()
  @objc open func engineDidReceivePong()
  @objc open func engineDidSendPong()
  @objc open func engineDidWebsocketUpgrade(headers: [Swift.String : Swift.String])
  @objc open func parseEngineMessage(_ msg: Swift.String)
  @objc open func parseEngineBinaryData(_ data: Foundation.Data)
  open func reconnect()
  @discardableResult
  open func removeSocket(_ socket: SocketIOClient) -> SocketIOClient?
  open func setConfigs(_ config: SocketIOClientConfiguration)
  open func socket(forNamespace nsp: Swift.String) -> SocketIOClient
}
public enum SocketAckStatus : Swift.String {
  case noAck
  public static func == (lhs: Swift.String, rhs: SocketAckStatus) -> Swift.Bool
  public static func == (lhs: SocketAckStatus, rhs: Swift.String) -> Swift.Bool
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol CompressionHandler {
  func load(headers: [Swift.String : Swift.String])
  func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
  func compress(data: Foundation.Data) -> Foundation.Data?
}
public protocol SocketData {
  func socketRepresentation() throws -> any SocketData
}
extension SocketData {
  public func socketRepresentation() -> any SocketData
}
extension Swift.Array : SocketData {
}
extension Swift.Bool : SocketData {
}
extension Swift.Dictionary : SocketData {
}
extension Swift.Double : SocketData {
}
extension Swift.Int : SocketData {
}
extension Foundation.NSArray : SocketData {
}
extension Foundation.Data : SocketData {
}
extension Foundation.NSData : SocketData {
}
extension Foundation.NSDictionary : SocketData {
}
extension Foundation.NSString : SocketData {
}
extension Foundation.NSNull : SocketData {
}
extension Swift.String : SocketData {
}
public typealias AckCallback = ([Any]) -> ()
public typealias NormalCallback = ([Any], SocketAckEmitter) -> ()
public typealias Post = (msg: Swift.String, completion: (() -> ())?)
@objc @_inheritsConvenienceInitializers @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public class NativeEngine : ObjectiveC.NSObject, Engine, Foundation.URLSessionDataDelegate, Foundation.URLSessionWebSocketDelegate {
  public func register(delegate: any EngineDelegate)
  public func start(request: Foundation.URLRequest)
  public func stop(closeCode: Swift.UInt16)
  public func forceStop()
  public func write(string: Swift.String, completion: (() -> ())?)
  public func write(data: Foundation.Data, opcode: FrameOpCode, completion: (() -> ())?)
  @objc public func urlSession(_ session: Foundation.URLSession, webSocketTask: Foundation.URLSessionWebSocketTask, didOpenWithProtocol protocol: Swift.String?)
  @objc public func urlSession(_ session: Foundation.URLSession, webSocketTask: Foundation.URLSessionWebSocketTask, didCloseWith closeCode: Foundation.URLSessionWebSocketTask.CloseCode, reason: Foundation.Data?)
  @objc public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: (any Swift.Error)?)
  @objc override dynamic public init()
  @objc deinit
}
public enum CloseCode : Swift.UInt16 {
  case normal
  case goingAway
  case protocolError
  case protocolUnhandledType
  case noStatusReceived
  case encoding
  case policyViolated
  case messageTooBig
  public init?(rawValue: Swift.UInt16)
  public typealias RawValue = Swift.UInt16
  public var rawValue: Swift.UInt16 {
    get
  }
}
public enum FrameOpCode : Swift.UInt8 {
  case continueFrame
  case textFrame
  case binaryFrame
  case connectionClose
  case ping
  case pong
  case unknown
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public struct Frame {
}
public enum FrameEvent {
  case frame(Frame)
  case error(any Swift.Error)
}
public protocol FramerEventClient : AnyObject {
  func frameProcessed(event: FrameEvent)
}
public protocol Framer {
  func add(data: Foundation.Data)
  func register(delegate: any FramerEventClient)
  func createWriteFrame(opcode: FrameOpCode, payload: Foundation.Data, isCompressed: Swift.Bool) -> Foundation.Data
  func updateCompression(supports: Swift.Bool)
  func supportsCompression() -> Swift.Bool
}
public class WSFramer : Framer {
  public var compressionEnabled: Swift.Bool
  public init(isServer: Swift.Bool = false)
  public func updateCompression(supports: Swift.Bool)
  public func supportsCompression() -> Swift.Bool
  public func add(data: Foundation.Data)
  public func register(delegate: any FramerEventClient)
  public func createWriteFrame(opcode: FrameOpCode, payload: Foundation.Data, isCompressed: Swift.Bool) -> Foundation.Data
  @objc deinit
}
public protocol MyWSArrayType {
}
extension Swift.UInt8 : MyWSArrayType {
}
extension Swift.Array where Element : MyWSArrayType, Element : Swift.UnsignedInteger {
  public func readUint16(offset: Swift.Int) -> Swift.UInt16
  public func readUint64(offset: Swift.Int) -> Swift.UInt64
  public func unmaskData(maskStart: Swift.Int, offset: Swift.Int, length: Swift.Int) -> Foundation.Data
}
public func writeUint16(_ buffer: inout [Swift.UInt8], offset: Swift.Int, value: Swift.UInt16)
public func writeUint32(_ buffer: inout [Swift.UInt8], offset: Swift.Int, value: Swift.UInt32)
public func writeUint64(_ buffer: inout [Swift.UInt8], offset: Swift.Int, value: Swift.UInt64)
@_hasMissingDesignatedInitializers public class FoundationHTTPServerHandler : HTTPServerHandler {
  public func register(delegate: any HTTPServerDelegate)
  public func createResponse(headers: [Swift.String : Swift.String]) -> Foundation.Data
  public func parse(data: Foundation.Data)
  @objc deinit
}
public protocol SocketManagerSpec : SocketEngineClient {
  var defaultSocket: SocketIOClient { get }
  var engine: (any SocketEngineSpec)? { get set }
  var forceNew: Swift.Bool { get set }
  var handleQueue: Dispatch.DispatchQueue { get set }
  var nsps: [Swift.String : SocketIOClient] { get set }
  var reconnects: Swift.Bool { get set }
  var reconnectWait: Swift.Int { get set }
  var reconnectWaitMax: Swift.Int { get set }
  var randomizationFactor: Swift.Double { get set }
  var socketURL: Foundation.URL { get }
  var status: SocketIOStatus { get }
  var version: SocketIOVersion { get }
  func connect()
  func connectSocket(_ socket: SocketIOClient, withPayload: [Swift.String : Any]?)
  func didDisconnect(reason: Swift.String)
  func disconnect()
  func disconnectSocket(_ socket: SocketIOClient)
  func disconnectSocket(forNamespace nsp: Swift.String)
  func emitAll(_ event: Swift.String, _ items: any SocketData...)
  func reconnect()
  @discardableResult
  func removeSocket(_ socket: SocketIOClient) -> SocketIOClient?
  func socket(forNamespace nsp: Swift.String) -> SocketIOClient
}
@_inheritsConvenienceInitializers @objc @_Concurrency.MainActor @preconcurrency public class CarouselController : UIKit.UIViewController, UIKit.UIGestureRecognizerDelegate {
  @objc @_Concurrency.MainActor @preconcurrency public var data: Swift.String
  @objc @_Concurrency.MainActor @preconcurrency public var titleNoti: Swift.String
  @objc @_Concurrency.MainActor @preconcurrency public var subTitleNoti: Swift.String
  @objc @_Concurrency.MainActor @preconcurrency public var bodyNoti: Swift.String
  @objc @_Concurrency.MainActor @preconcurrency public var titleHeight: CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor @preconcurrency public var subtitleHeight: CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor @preconcurrency public var bodyHeight: CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor @preconcurrency public var viewHeight: CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor @preconcurrency public var isContainActionButton: Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public protocol EngineDelegate : AnyObject {
  func didReceive(event: WebSocketEvent)
}
public protocol Engine {
  func register(delegate: any EngineDelegate)
  func start(request: Foundation.URLRequest)
  func stop(closeCode: Swift.UInt16)
  func forceStop()
  func write(data: Foundation.Data, opcode: FrameOpCode, completion: (() -> ())?)
  func write(string: Swift.String, completion: (() -> ())?)
}
public enum HTTPUpgradeError : Swift.Error {
  case notAnUpgrade(Swift.Int, [Swift.String : Swift.String])
  case invalidData
}
public struct HTTPWSHeader {
  public static func createUpgrade(request: Foundation.URLRequest, supportsCompression: Swift.Bool, secKeyValue: Swift.String) -> Foundation.URLRequest
  public static func generateWebSocketKey() -> Swift.String
}
public enum HTTPEvent {
  case success([Swift.String : Swift.String])
  case failure(any Swift.Error)
}
public protocol HTTPHandlerDelegate : AnyObject {
  func didReceiveHTTP(event: HTTPEvent)
}
public protocol HTTPHandler {
  func register(delegate: any HTTPHandlerDelegate)
  func convert(request: Foundation.URLRequest) -> Foundation.Data
  func parse(data: Foundation.Data) -> Swift.Int
}
public protocol HTTPServerDelegate : AnyObject {
  func didReceive(event: HTTPEvent)
}
public protocol HTTPServerHandler {
  func register(delegate: any HTTPServerDelegate)
  func parse(data: Foundation.Data)
  func createResponse(headers: [Swift.String : Swift.String]) -> Foundation.Data
}
public struct URLParts {
}
extension Foundation.URL {
  public var isTLSScheme: Swift.Bool {
    get
  }
  public func getParts() -> URLParts?
}
@_inheritsConvenienceInitializers @objc public class AntsomiUtiltiy : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class AntsomiUNUserNotificationCenter : UIKit.UIResponder, UIKit.UIApplicationDelegate, UserNotifications.UNUserNotificationCenterDelegate {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init()
  @_Concurrency.MainActor @preconcurrency open func setActionForUrl(_ actionForUrl: @escaping (Swift.String) -> Swift.Void)
  @_Concurrency.MainActor @preconcurrency open func onNotificationPressed(_ completion: @escaping ([Swift.String : Any]) -> ())
  @_Concurrency.MainActor @preconcurrency open func setActionForDismiss(_ actionForDismiss: @escaping () -> Swift.Void)
  @_Concurrency.MainActor @preconcurrency open func setActionForDefault(_ actionForDefault: @escaping () -> Swift.Void)
  @_Concurrency.MainActor @preconcurrency open func setActionForCustomDefault(_ actionForCustomDefault: @escaping (Swift.String) -> Swift.Void)
  @_Concurrency.MainActor @preconcurrency @objc public func userNotificationCenter(_ center: UserNotifications.UNUserNotificationCenter, willPresent notification: UserNotifications.UNNotification, withCompletionHandler completionHandler: @escaping (UserNotifications.UNNotificationPresentationOptions) -> Swift.Void)
  @_Concurrency.MainActor @preconcurrency @objc public func userNotificationCenter(_ center: UserNotifications.UNUserNotificationCenter, didReceive response: UserNotifications.UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Swift.Void)
  @objc deinit
}
public protocol FrameCollectorDelegate : AnyObject {
  func didForm(event: FrameCollector.Event)
  func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
}
@_hasMissingDesignatedInitializers public class FrameCollector {
  public enum Event {
    case text(Swift.String)
    case binary(Foundation.Data)
    case pong(Foundation.Data?)
    case ping(Foundation.Data?)
    case error(any Swift.Error)
    case closed(Swift.String, Swift.UInt16)
  }
  public func add(frame: Frame)
  @objc deinit
}
public enum FoundationSecurityError : Swift.Error {
  case invalidRequest
  public static func == (a: FoundationSecurityError, b: FoundationSecurityError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class FoundationSecurity {
  public init(allowSelfSigned: Swift.Bool = false)
  @objc deinit
}
extension FoundationSecurity : CertificatePinning {
  public func evaluateTrust(trust: Security.SecTrust, domain: Swift.String?, completion: ((PinningState) -> ()))
}
extension FoundationSecurity : HeaderValidator {
  public func validate(headers: [Swift.String : Swift.String], key: Swift.String) -> (any Swift.Error)?
}
public protocol AppInboxDelegate : AnyObject {
  func onNewMessage(_ newMessageReceived: InboxItem)
}
@objc public class AppInbox : ObjectiveC.NSObject {
  weak public var delegate: (any AppInboxDelegate)?
  public var lookupId: Swift.String
  public var lookupType: Swift.String
  public static var pageLimit: Swift.Int
  public static func setPageLimit(pageLimit: Swift.Int)
  public init(destinationId: Swift.String, audienceType: Swift.String, log: Swift.Bool = false)
  public func getMessage() -> [InboxItem]
  public func countUnreadMessage(completion: @escaping ((Swift.Int) -> Swift.Void))
  public func getMessageById(messageId: Swift.String, completion: @escaping ((InboxItem) -> Swift.Void))
  public func forceFetchInboxItem(catalogId: [Swift.String] = [], page: Swift.Int, completion: @escaping (([InboxItem]) -> Swift.Void))
  public func markAllAsRead()
  public func modifyMessageStatus(_ messageId: [Swift.String], action: ModifyAction)
  public func fetchAllCatalog(completion: @escaping (([Catalog]) -> Swift.Void))
  @objc deinit
}
public struct Catalog : Swift.Codable {
  public var catalogId: Swift.String
  public var catalogName: Swift.String
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Catalog {
  public func jsonData() throws -> Foundation.Data
  public func jsonString(encoding: Swift.String.Encoding = .utf8) throws -> Swift.String?
}
public enum ConnectionEvent {
  case connected([Swift.String : Swift.String])
  case disconnected(Swift.String, Swift.UInt16)
  case text(Swift.String)
  case binary(Foundation.Data)
  case pong(Foundation.Data?)
  case ping(Foundation.Data?)
  case error(any Swift.Error)
}
public protocol Connection {
  func write(data: Foundation.Data, opcode: FrameOpCode)
}
public protocol ConnectionDelegate : AnyObject {
  func didReceive(event: ServerEvent)
}
public enum ServerEvent {
  case connected(any Connection, [Swift.String : Swift.String])
  case disconnected(any Connection, Swift.String, Swift.UInt16)
  case text(any Connection, Swift.String)
  case binary(any Connection, Foundation.Data)
  case pong(any Connection, Foundation.Data?)
  case ping(any Connection, Foundation.Data?)
}
public protocol Server {
  func start(address: Swift.String, port: Swift.UInt16) -> (any Swift.Error)?
}
@objc @_inheritsConvenienceInitializers @objcMembers public class Antsomi : ObjectiveC.NSObject {
  @objc public static let SDK_VERSION: Swift.String
  @objc public var isAssociatedUTM: Swift.Bool
  @objc public static var appInbox: AppInbox!
  @objc @Atomic public var isDelivery: Swift.Bool {
    @objc get
    @objc set
    _modify
  }
  @objc @Atomic public var isShowingTemplate: Swift.Bool {
    @objc get
    @objc set
    _modify
  }
  @objc public var callbackHandleRedirectTemplate: ((Swift.String) -> Swift.Void)?
  public struct Configuration {
    public let portalId: Swift.String
    public let propsId: Swift.String
    public let applicationId: Swift.String
    public let appGroupId: Swift.String
    public init(portalId: Swift.String, propsId: Swift.String, appGroupId: Swift.String, applicationId: Swift.String)
  }
  @objc public var debug: Swift.Bool
  @objc public var logger: ((Swift.String) -> Swift.Void)?
  @objc public func log(_ str: Swift.String)
  @objc public static var shared: Antsomi
  @objc public func setCustomerProperties(customerId: Swift.String, customerProperties: [Swift.String : Any] = [:])
  @objc public func setUid(uid: Swift.String)
  @objc public func resetUid()
  @objc public func getUid() -> Swift.String
  @objc public func setIsDelivery(newValue: Swift.Bool)
  @objc public func resetCustomer()
  @objc public func getCustomerId() -> Swift.String
  @objc public func getPropsId() -> Swift.String
  @objc public func getCustomerProperties() -> [Swift.String : Any]?
  @objc public func getDeviceId() -> Swift.String
  @objc public func getPortalId() -> Swift.String?
  @objc public func getAppGroupId() -> Swift.String?
  @objc public func appInboxInit(destinationId: Swift.String, audienceType: Swift.String)
  public func track(event: CDPEvent)
  public func getMediaJson(event: CDPEvent, completion: @escaping (([Swift.String : Any]) -> Swift.Void))
  public func getMediaJson(event: CDPEvent, storyId: Swift.String, completion: @escaping (([Swift.String : Any]) -> Swift.Void))
  @objc public func processGetMediaJson(eventBody: [Swift.String : Any], completion: @escaping (([Swift.String : Any]) -> Swift.Void))
  @objc public func handleViewTrackingUrl(_ url: Foundation.URL)
  @objc public func handleTrackingURL(_ url: Foundation.URL, completion: @escaping (() -> ()))
  @objc public func handleDeeplinkURL(_ url: Foundation.URL)
  public func activate(with config: Antsomi.Configuration)
  @objc public func getPushUid() -> Swift.String?
  @objc public func trackAppLaunch()
  @objc public func requestNotificationPermission()
  @objc public func registerForNotification(_ deviceToken: Foundation.Data)
  @objc public func trackScreen(name: Swift.String, title: Swift.String = "", type: Swift.String = "")
  @objc public func setHandleChangeRouteTemplate(_ callback: @escaping (Swift.String) -> Swift.Void)
  @objc public static func getBundleId() -> Swift.String
  @objc public func md5(string: Swift.String) -> Swift.String
  public func getReaderSegment(email: Swift.String, completion: @escaping ((ReaderSegment) -> Swift.Void))
  @objc override dynamic public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class UserDefaultsManager : ObjectiveC.NSObject {
  public static var userDefaults: Foundation.UserDefaults?
  @objc override dynamic public init()
  @objc deinit
}
public protocol SocketParsable : AnyObject {
  func parseBinaryData(_ data: Foundation.Data) -> SocketPacket?
  func parseSocketMessage(_ message: Swift.String) -> SocketPacket?
}
public enum SocketParsableError : Swift.Error {
  case invalidDataArray
  case invalidPacket
  case invalidPacketType
  public static func == (a: SocketParsableError, b: SocketParsableError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol SocketDataBufferable : AnyObject {
  var waitingPackets: [SocketPacket] { get set }
}
extension SocketParsable where Self : SocketDataBufferable, Self : SocketManagerSpec {
  public func parseSocketMessage(_ message: Swift.String) -> SocketPacket?
  public func parseBinaryData(_ data: Foundation.Data) -> SocketPacket?
}
@_inheritsConvenienceInitializers @objc @_Concurrency.MainActor @preconcurrency public class SmallImageController : UIKit.UIViewController, UIKit.UIGestureRecognizerDelegate {
  @objc @_Concurrency.MainActor @preconcurrency public var data: Swift.String
  @objc @_Concurrency.MainActor @preconcurrency public var titleNoti: Swift.String
  @objc @_Concurrency.MainActor @preconcurrency public var subTitleNoti: Swift.String
  @objc @_Concurrency.MainActor @preconcurrency public var bodyNoti: Swift.String
  @objc @_Concurrency.MainActor @preconcurrency public var isContainActionButton: Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension Foundation.Data {
  public func prependx509Header() -> Foundation.Data
  public func hasX509Header() throws -> Swift.Bool
  public func isAnHeaderlessKey() throws -> Swift.Bool
}
public class PrivateKey : Key {
  final public let reference: Security.SecKey
  final public let originalData: Foundation.Data?
  public func pemString() throws -> Swift.String
  required public init(reference: Security.SecKey) throws
  required public init(data: Foundation.Data) throws
  @objc deinit
}
public class Signature {
  public enum DigestType {
    case sha1
    case sha224
    case sha256
    case sha384
    case sha512
    public static func == (a: Signature.DigestType, b: Signature.DigestType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let data: Foundation.Data
  public init(data: Foundation.Data)
  convenience public init(base64Encoded base64String: Swift.String) throws
  public var base64String: Swift.String {
    get
  }
  @objc deinit
}
public protocol Key : AnyObject {
  var reference: Security.SecKey { get }
  var originalData: Foundation.Data? { get }
  init(data: Foundation.Data) throws
  init(reference: Security.SecKey) throws
  init(base64Encoded base64String: Swift.String) throws
  init(pemEncoded pemString: Swift.String) throws
  init(pemNamed pemName: Swift.String, in bundle: Foundation.Bundle) throws
  init(derNamed derName: Swift.String, in bundle: Foundation.Bundle) throws
  func pemString() throws -> Swift.String
  func data() throws -> Foundation.Data
  func base64String() throws -> Swift.String
}
extension Key {
  public func base64String() throws -> Swift.String
  public func data() throws -> Foundation.Data
  public init(base64Encoded base64String: Swift.String) throws
  public init(pemEncoded pemString: Swift.String) throws
  public init(pemNamed pemName: Swift.String, in bundle: Foundation.Bundle = Bundle.main) throws
  public init(derNamed derName: Swift.String, in bundle: Foundation.Bundle = Bundle.main) throws
}
public enum SwiftyRSAError : Swift.Error {
  case pemDoesNotContainKey
  case keyRepresentationFailed(error: CoreFoundation.CFError?)
  case keyGenerationFailed(error: CoreFoundation.CFError?)
  case keyCreateFailed(error: CoreFoundation.CFError?)
  case keyAddFailed(status: Darwin.OSStatus)
  case keyCopyFailed(status: Darwin.OSStatus)
  case tagEncodingFailed
  case asn1ParsingFailed
  case invalidAsn1RootNode
  case invalidAsn1Structure
  case invalidBase64String
  case chunkDecryptFailed(index: Swift.Int)
  case chunkEncryptFailed(index: Swift.Int)
  case stringToDataConversionFailed
  case dataToStringConversionFailed
  case invalidDigestSize(digestSize: Swift.Int, maxChunkSize: Swift.Int)
  case signatureCreateFailed(status: Darwin.OSStatus)
  case signatureVerifyFailed(status: Darwin.OSStatus)
  case pemFileNotFound(name: Swift.String)
  case derFileNotFound(name: Swift.String)
  case notAPublicKey
  case notAPrivateKey
  case x509CertificateFailed
}
extension SwiftyRSAError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public protocol Message {
  var data: Foundation.Data { get }
  var base64String: Swift.String { get }
  init(data: Foundation.Data)
  init(base64Encoded base64String: Swift.String) throws
}
extension Message {
  public var base64String: Swift.String {
    get
  }
  public init(base64Encoded base64String: Swift.String) throws
}
public class ClearMessage : Message {
  final public let data: Foundation.Data
  required public init(data: Foundation.Data)
  convenience public init(string: Swift.String, using encoding: Swift.String.Encoding) throws
  public func string(encoding: Swift.String.Encoding) throws -> Swift.String
  public func encrypted(with key: PublicKey, padding: Padding) throws -> EncryptedMessage
  public func signed(with key: PrivateKey, digestType: Signature.DigestType) throws -> Signature
  public func verify(with key: PublicKey, signature: Signature, digestType: Signature.DigestType) throws -> Swift.Bool
  @objc deinit
}
public typealias Padding = Security.SecPadding
public enum SwiftyRSA {
  @available(iOS 10.0, watchOS 3.0, tvOS 10.0, *)
  public static func generateRSAKeyPair(sizeInBits size: Swift.Int) throws -> (privateKey: PrivateKey, publicKey: PublicKey)
}
public class PublicKey : Key {
  final public let reference: Security.SecKey
  final public let originalData: Foundation.Data?
  public func pemString() throws -> Swift.String
  required public init(reference: Security.SecKey) throws
  required public init(data: Foundation.Data) throws
  public static func publicKeys(pemEncoded pemString: Swift.String) -> [PublicKey]
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc(KeyPair) public class _objc_KeyPair : ObjectiveC.NSObject {
  @objc final public let privateKey: _objc_PrivateKey
  @objc final public let publicKey: _objc_PublicKey
  @objc deinit
}
@_inheritsConvenienceInitializers @objc(SwiftyRSA) public class _objc_SwiftyRSA : ObjectiveC.NSObject {
  @available(iOS 10.0, watchOS 3.0, tvOS 10.0, *)
  @objc public class func generateRSAKeyPair(sizeInBits size: Swift.Int) throws -> _objc_KeyPair
  @objc override dynamic public init()
  @objc deinit
}
@objc(PublicKey) public class _objc_PublicKey : ObjectiveC.NSObject, Key {
  @objc public var reference: Security.SecKey {
    @objc get
  }
  @objc public var originalData: Foundation.Data? {
    @objc get
  }
  @objc public func pemString() throws -> Swift.String
  @objc public func data() throws -> Foundation.Data
  @objc public func base64String() throws -> Swift.String
  required public init(swiftValue: PublicKey)
  @objc required public init(data: Foundation.Data) throws
  @objc required public init(reference: Security.SecKey) throws
  @objc required public init(base64Encoded base64String: Swift.String) throws
  @objc required public init(pemEncoded pemString: Swift.String) throws
  @objc required public init(pemNamed pemName: Swift.String, in bundle: Foundation.Bundle) throws
  @objc required public init(derNamed derName: Swift.String, in bundle: Foundation.Bundle) throws
  @objc public static func publicKeys(pemEncoded pemString: Swift.String) -> [_objc_PublicKey]
  @objc deinit
}
@objc(PrivateKey) public class _objc_PrivateKey : ObjectiveC.NSObject, Key {
  @objc public var reference: Security.SecKey {
    @objc get
  }
  @objc public var originalData: Foundation.Data? {
    @objc get
  }
  @objc public func pemString() throws -> Swift.String
  @objc public func data() throws -> Foundation.Data
  @objc public func base64String() throws -> Swift.String
  required public init(swiftValue: PrivateKey)
  @objc required public init(data: Foundation.Data) throws
  @objc required public init(reference: Security.SecKey) throws
  @objc required public init(base64Encoded base64String: Swift.String) throws
  @objc required public init(pemEncoded pemString: Swift.String) throws
  @objc required public init(pemNamed pemName: Swift.String, in bundle: Foundation.Bundle) throws
  @objc required public init(derNamed derName: Swift.String, in bundle: Foundation.Bundle) throws
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc(VerificationResult) public class _objc_VerificationResult : ObjectiveC.NSObject {
  @objc final public let isSuccessful: Swift.Bool
  @objc deinit
}
@objc(ClearMessage) public class _objc_ClearMessage : ObjectiveC.NSObject, Message {
  @objc public var base64String: Swift.String {
    @objc get
  }
  @objc public var data: Foundation.Data {
    @objc get
  }
  required public init(swiftValue: ClearMessage)
  @objc required public init(data: Foundation.Data)
  @objc required public init(string: Swift.String, using rawEncoding: Swift.UInt) throws
  @objc required public init(base64Encoded base64String: Swift.String) throws
  @objc public func string(encoding rawEncoding: Swift.UInt) throws -> Swift.String
  @objc public func encrypted(with key: _objc_PublicKey, padding: Padding) throws -> _objc_EncryptedMessage
  @objc public func signed(with key: _objc_PrivateKey, digestType: _objc_Signature.DigestType) throws -> _objc_Signature
  @objc public func verify(with key: _objc_PublicKey, signature: _objc_Signature, digestType: _objc_Signature.DigestType) throws -> _objc_VerificationResult
  @objc deinit
}
@objc(EncryptedMessage) public class _objc_EncryptedMessage : ObjectiveC.NSObject, Message {
  @objc public var base64String: Swift.String {
    @objc get
  }
  @objc public var data: Foundation.Data {
    @objc get
  }
  required public init(swiftValue: EncryptedMessage)
  @objc required public init(data: Foundation.Data)
  @objc required public init(base64Encoded base64String: Swift.String) throws
  @objc public func decrypted(with key: _objc_PrivateKey, padding: Padding) throws -> _objc_ClearMessage
  @objc deinit
}
@objc(Signature) public class _objc_Signature : ObjectiveC.NSObject {
  @objc public enum DigestType : Swift.Int {
    case sha1
    case sha224
    case sha256
    case sha384
    case sha512
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc public var base64String: Swift.String {
    @objc get
  }
  @objc public var data: Foundation.Data {
    @objc get
  }
  required public init(swiftValue: Signature)
  @objc public init(data: Foundation.Data)
  @objc required public init(base64Encoded base64String: Swift.String) throws
  @objc deinit
}
public class EncryptedMessage : Message {
  final public let data: Foundation.Data
  required public init(data: Foundation.Data)
  public func decrypted(with key: PrivateKey, padding: Padding) throws -> ClearMessage
  @objc deinit
}
@_inheritsConvenienceInitializers @objc public class PushTemplateBaseController : ObjectiveC.NSObject {
  @objc public static func handleNotification(withController controller: UIKit.UIViewController, withNotification notification: UserNotifications.UNNotification)
  @objc override dynamic public init()
  @objc deinit
}
public enum ConnectionState {
  case connected
  case waiting
  case cancelled
  case failed((any Swift.Error)?)
  case viability(Swift.Bool)
  case shouldReconnect(Swift.Bool)
  case receive(Foundation.Data)
  case peerClosed
}
public protocol TransportEventClient : AnyObject {
  func connectionChanged(state: ConnectionState)
}
public protocol Transport : AnyObject {
  func register(delegate: any TransportEventClient)
  func connect(url: Foundation.URL, timeout: Swift.Double, certificatePinning: (any CertificatePinning)?)
  func disconnect()
  func write(data: Foundation.Data, completion: @escaping (((any Swift.Error)?) -> ()))
  var usingTLS: Swift.Bool { get }
}
@objc @_hasMissingDesignatedInitializers final public class SocketRawView : ObjectiveC.NSObject {
  final public func emit(_ event: Swift.String, _ items: any SocketData...)
  @objc final public func emit(_ event: Swift.String, with items: [Any])
  final public func emitWithAck(_ event: Swift.String, _ items: any SocketData...) -> OnAckCallback
  @objc final public func emitWithAck(_ event: Swift.String, with items: [Any]) -> OnAckCallback
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers final public class SocketRawAckView : ObjectiveC.NSObject {
  final public func with(_ items: any SocketData...)
  @objc final public func with(_ items: [Any])
  @objc deinit
}
public enum TCPTransportError : Swift.Error {
  case invalidRequest
  public static func == (a: TCPTransportError, b: TCPTransportError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
public class TCPTransport : Transport {
  @objc deinit
  public var usingTLS: Swift.Bool {
    get
  }
  public init(connection: Network.NWConnection)
  public init()
  public func connect(url: Foundation.URL, timeout: Swift.Double = 10, certificatePinning: (any CertificatePinning)? = nil)
  public func disconnect()
  public func register(delegate: any TransportEventClient)
  public func write(data: Foundation.Data, completion: @escaping (((any Swift.Error)?) -> ()))
}
public enum ModifyAction : Swift.Int, Swift.CaseIterable, Swift.Codable {
  case unread
  case read
  case remove
  public init?(rawValue: Swift.Int)
  public typealias AllCases = [ModifyAction]
  public typealias RawValue = Swift.Int
  nonisolated public static var allCases: [ModifyAction] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
public class FoundationHTTPHandler : HTTPHandler {
  public init()
  public func convert(request: Foundation.URLRequest) -> Foundation.Data
  public func parse(data: Foundation.Data) -> Swift.Int
  public func register(delegate: any HTTPHandlerDelegate)
  @objc deinit
}
public protocol SocketEnginePollable : SocketEngineSpec {
  var invalidated: Swift.Bool { get }
  var postWait: [Post] { get set }
  var session: Foundation.URLSession? { get }
  var waitingForPoll: Swift.Bool { get set }
  var waitingForPost: Swift.Bool { get set }
  func doPoll()
  func sendPollMessage(_ message: Swift.String, withType type: SocketEnginePacketType, withData datas: [Foundation.Data], completion: (() -> ())?)
  func stopPolling()
}
extension SocketEnginePollable {
  public func doPoll()
  public func sendPollMessage(_ message: Swift.String, withType type: SocketEnginePacketType, withData datas: [Foundation.Data], completion: (() -> ())? = nil)
  public func stopPolling()
}
public enum SecurityErrorCode : Swift.UInt16 {
  case acceptFailed
  case pinningFailed
  public init?(rawValue: Swift.UInt16)
  public typealias RawValue = Swift.UInt16
  public var rawValue: Swift.UInt16 {
    get
  }
}
public enum PinningState {
  case success
  case failed(CoreFoundation.CFError?)
}
public protocol CertificatePinning : AnyObject {
  func evaluateTrust(trust: Security.SecTrust, domain: Swift.String?, completion: ((PinningState) -> ()))
}
public protocol HeaderValidator : AnyObject {
  func validate(headers: [Swift.String : Swift.String], key: Swift.String) -> (any Swift.Error)?
}
@objc @_inheritsConvenienceInitializers public class Context : ObjectiveC.NSObject {
  public var deviceID: Swift.String?
  public func execute() -> [Swift.String : Any]
  @objc override dynamic public init()
  @objc deinit
}
public enum ErrorType : Swift.Error {
  case compressionError
  case securityError
  case protocolError
  case serverError
  public static func == (a: ErrorType, b: ErrorType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct WSError : Swift.Error {
  public let type: ErrorType
  public let message: Swift.String
  public let code: Swift.UInt16
  public init(type: ErrorType, message: Swift.String, code: Swift.UInt16)
}
public protocol WebSocketClient : AnyObject {
  func connect()
  func disconnect(closeCode: Swift.UInt16)
  func write(string: Swift.String, completion: (() -> ())?)
  func write(stringData: Foundation.Data, completion: (() -> ())?)
  func write(data: Foundation.Data, completion: (() -> ())?)
  func write(ping: Foundation.Data, completion: (() -> ())?)
  func write(pong: Foundation.Data, completion: (() -> ())?)
}
extension WebSocketClient {
  public func write(string: Swift.String)
  public func write(data: Foundation.Data)
  public func write(ping: Foundation.Data)
  public func write(pong: Foundation.Data)
  public func disconnect()
}
public enum WebSocketEvent {
  case connected([Swift.String : Swift.String])
  case disconnected(Swift.String, Swift.UInt16)
  case text(Swift.String)
  case binary(Foundation.Data)
  case pong(Foundation.Data?)
  case ping(Foundation.Data?)
  case error((any Swift.Error)?)
  case viabilityChanged(Swift.Bool)
  case reconnectSuggested(Swift.Bool)
  case cancelled
  case peerClosed
}
public protocol WebSocketDelegate : AnyObject {
  func didReceive(event: WebSocketEvent, client: any WebSocketClient)
}
open class WebSocket : WebSocketClient, EngineDelegate {
  weak public var delegate: (any WebSocketDelegate)?
  public var onEvent: ((WebSocketEvent) -> Swift.Void)?
  public var request: Foundation.URLRequest
  public var callbackQueue: Dispatch.DispatchQueue
  public var respondToPingWithPong: Swift.Bool {
    get
    set
  }
  public init(request: Foundation.URLRequest, engine: any Engine)
  convenience public init(request: Foundation.URLRequest, certPinner: (any CertificatePinning)? = FoundationSecurity(), compressionHandler: (any CompressionHandler)? = nil, useCustomEngine: Swift.Bool = true)
  public func connect()
  public func disconnect(closeCode: Swift.UInt16 = CloseCode.normal.rawValue)
  public func forceDisconnect()
  public func write(data: Foundation.Data, completion: (() -> ())?)
  public func write(string: Swift.String, completion: (() -> ())?)
  public func write(stringData: Foundation.Data, completion: (() -> ())?)
  public func write(ping: Foundation.Data, completion: (() -> ())?)
  public func write(pong: Foundation.Data, completion: (() -> ())?)
  public func didReceive(event: WebSocketEvent)
  @objc deinit
}
public struct ReaderSegment : Swift.Codable {
  public var customerId: Swift.String
  public var segmentName: Swift.String
  public var totalReadToday: Swift.Int
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@objc public protocol SocketEngineClient {
  @objc func engineDidError(reason: Swift.String)
  @objc func engineDidClose(reason: Swift.String)
  @objc func engineDidOpen(reason: Swift.String)
  @objc func engineDidReceivePing()
  @objc func engineDidReceivePong()
  @objc func engineDidSendPing()
  @objc func engineDidSendPong()
  @objc func parseEngineMessage(_ msg: Swift.String)
  @objc func parseEngineBinaryData(_ data: Foundation.Data)
  @objc func engineDidWebsocketUpgrade(headers: [Swift.String : Swift.String])
}
public struct SocketEventHandler {
  public let event: Swift.String
  public let id: Foundation.UUID
  public let callback: NormalCallback
  public func executeCallback(with items: [Any], withAck ack: Swift.Int, withSocket socket: SocketIOClient)
}
@propertyWrapper public class Atomic<T> {
  public init(wrappedValue value: T)
  public var wrappedValue: T {
    get
    set
  }
  @objc deinit
}
public struct CDPEvent : Swift.Encodable {
  public mutating func setEventName(eventName: Swift.String)
  public mutating func setObjectProperties(objectProperties: [Swift.String : Any])
  public mutating func setEventProperties(eventProperties: [Swift.String : Any])
  public mutating func setItems(items: [[Swift.String : Any]])
  public mutating func setScreenType(type: Swift.String)
  public mutating func setCustomerProperties(customerProperties: [Swift.String : Any])
  public mutating func setUserPropperties(userPropperties: [Swift.String : Any])
  public mutating func setScreenName(screenName: Swift.String)
  public mutating func setPropsId(propId: Swift.String)
  public func getPropsId() -> Swift.String
  public init(en: Swift.String = "", items: [[Swift.String : Any]] = [], userProps: [Swift.String : Any] = [:], customerProps: [Swift.String : Any] = [:], objectProps: [Swift.String : Any] = [:], evetProps: [Swift.String : Any] = [:], screenType: Swift.String = "", screenLabel: Swift.String = "", screenName: Swift.String = "")
  public func encode(to encoder: any Swift.Encoder) throws
}
@objc public enum SocketIOStatus : Swift.Int, Swift.CustomStringConvertible {
  case notConnected
  case disconnected
  case connecting
  case connected
  public var active: Swift.Bool {
    get
  }
  public var description: Swift.String {
    get
  }
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum SocketEnginePacketType : Swift.Int {
  case open
  case close
  case ping
  case pong
  case message
  case upgrade
  case noop
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public class WSCompression : CompressionHandler {
  public init()
  public func load(headers: [Swift.String : Swift.String])
  public func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
  public func compress(data: Foundation.Data) -> Foundation.Data?
  @objc deinit
}
public protocol SocketEngineWebsocket : SocketEngineSpec {
  var wsConnected: Swift.Bool { get }
  func sendWebSocketMessage(_ str: Swift.String, withType type: SocketEnginePacketType, withData datas: [Foundation.Data], completion: (() -> ())?)
}
extension SocketEngineWebsocket {
  public func sendWebSocketMessage(_ str: Swift.String, withType type: SocketEnginePacketType, withData data: [Foundation.Data], completion: (() -> ())?)
}
public struct SocketPacket : Swift.CustomStringConvertible {
  public let nsp: Swift.String
  public let id: Swift.Int
  public let type: SocketPacket.PacketType
  public var binary: [Foundation.Data] {
    get
  }
  public var data: [Any] {
    get
  }
  public var args: [Any] {
    get
  }
  public var description: Swift.String {
    get
  }
  public var event: Swift.String {
    get
  }
  public var packetString: Swift.String {
    get
  }
}
extension SocketPacket {
  public enum PacketType : Swift.Int {
    case connect
    case disconnect
    case event
    case ack
    case error
    case binaryEvent
    case binaryAck
    public var isBinary: Swift.Bool {
      get
    }
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
@objc @_hasMissingDesignatedInitializers final public class SocketAnyEvent : ObjectiveC.NSObject {
  @objc final public let event: Swift.String
  @objc final public let items: [Any]?
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc deinit
}
public enum FoundationTransportError : Swift.Error {
  case invalidRequest
  case invalidOutputStream
  case timeout
  public static func == (a: FoundationTransportError, b: FoundationTransportError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc public class FoundationTransport : ObjectiveC.NSObject, Transport, Foundation.StreamDelegate {
  public var usingTLS: Swift.Bool {
    get
  }
  public init(streamConfiguration: ((Foundation.InputStream, Foundation.OutputStream) -> Swift.Void)? = nil)
  @objc deinit
  public func connect(url: Foundation.URL, timeout: Swift.Double = 10, certificatePinning: (any CertificatePinning)? = nil)
  public func disconnect()
  public func register(delegate: any TransportEventClient)
  public func write(data: Foundation.Data, completion: @escaping (((any Swift.Error)?) -> ()))
  @objc open func stream(_ aStream: Foundation.Stream, handle eventCode: Foundation.Stream.Event)
}
public struct InboxItem : Swift.Codable {
  public var itemId: Swift.String
  public var lastUpdated: Swift.String
  public var heading: Swift.String
  public var dateCreated: Swift.String
  public var catalogId: [Swift.String]
  public var lauchUrl: Foundation.URL?
  public var lookupType: Swift.String
  public var templateId: Swift.String
  public var content: Swift.String
  public var appUrl: Foundation.URL?
  public var status: Swift.Int
  public var imageUrl: Foundation.URL?
  public var buttonAppUrl1: Foundation.URL?
  public var buttonAppUrl2: Foundation.URL?
  public var buttonLaunchUrl1: Foundation.URL?
  public var buttonLaunchUrl2: Foundation.URL?
  public var buttonLabel1: Swift.String?
  public var buttonLabel2: Swift.String?
  public var trackingUrl: Foundation.URL?
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension InboxItem {
  public func jsonData() throws -> Foundation.Data
  public func jsonString(encoding: Swift.String.Encoding = .utf8) throws -> Swift.String?
}
public enum SocketIOVersion : Swift.Int {
  case two
  case three
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum SocketIOClientOption {
  case compress
  case connectParams([Swift.String : Any])
  case cookies([Foundation.HTTPCookie])
  case extraHeaders([Swift.String : Swift.String])
  case forceNew(Swift.Bool)
  case forcePolling(Swift.Bool)
  case forceWebsockets(Swift.Bool)
  case enableSOCKSProxy(Swift.Bool)
  case handleQueue(Dispatch.DispatchQueue)
  case log(Swift.Bool)
  case logger(any SocketLogger)
  case path(Swift.String)
  case reconnects(Swift.Bool)
  case reconnectAttempts(Swift.Int)
  case reconnectWait(Swift.Int)
  case reconnectWaitMax(Swift.Int)
  case randomizationFactor(Swift.Double)
  case secure(Swift.Bool)
  case security(any CertificatePinning)
  case selfSigned(Swift.Bool)
  case sessionDelegate(any Foundation.URLSessionDelegate)
  case useCustomEngine(Swift.Bool)
  case version(SocketIOVersion)
  public var description: Swift.String {
    get
  }
  public static func == (lhs: SocketIOClientOption, rhs: SocketIOClientOption) -> Swift.Bool
}
public protocol SocketLogger : AnyObject {
  var log: Swift.Bool { get set }
  func log(_ message: @autoclosure () -> Swift.String, type: Swift.String)
  func error(_ message: @autoclosure () -> Swift.String, type: Swift.String)
}
extension SocketLogger {
  public func log(_ message: @autoclosure () -> Swift.String, type: Swift.String)
  public func error(_ message: @autoclosure () -> Swift.String, type: Swift.String)
}
public protocol SocketEngineSpec : AnyObject {
  var client: (any SocketEngineClient)? { get set }
  var closed: Swift.Bool { get }
  var compress: Swift.Bool { get }
  var connected: Swift.Bool { get }
  var connectParams: [Swift.String : Any]? { get set }
  var cookies: [Foundation.HTTPCookie]? { get }
  var engineQueue: Dispatch.DispatchQueue { get }
  var extraHeaders: [Swift.String : Swift.String]? { get set }
  var fastUpgrade: Swift.Bool { get }
  var forcePolling: Swift.Bool { get }
  var forceWebsockets: Swift.Bool { get }
  var polling: Swift.Bool { get }
  var probing: Swift.Bool { get }
  var sid: Swift.String { get }
  var socketPath: Swift.String { get }
  var urlPolling: Foundation.URL { get }
  var urlWebSocket: Foundation.URL { get }
  var version: SocketIOVersion { get }
  @available(*, deprecated, message: "No longer needed, if we're not polling, then we must be doing websockets")
  var websocket: Swift.Bool { get }
  var ws: WebSocket? { get }
  init(client: any SocketEngineClient, url: Foundation.URL, options: [Swift.String : Any]?)
  func connect()
  func didError(reason: Swift.String)
  func disconnect(reason: Swift.String)
  func doFastUpgrade()
  func flushWaitingForPostToWebSocket()
  func parseEngineData(_ data: Foundation.Data)
  func parseEngineMessage(_ message: Swift.String)
  func write(_ msg: Swift.String, withType type: SocketEnginePacketType, withData data: [Foundation.Data], completion: (() -> ())?)
}
extension UIKit.UIDevice {
  @_Concurrency.MainActor @preconcurrency public static let modelName: Swift.String
}
@_inheritsConvenienceInitializers @objc @_Concurrency.MainActor @preconcurrency public class TextOverlayController : UIKit.UIViewController, UIKit.UIGestureRecognizerDelegate {
  @objc @_Concurrency.MainActor @preconcurrency public var data: Swift.String
  @objc @_Concurrency.MainActor @preconcurrency public var titleNoti: Swift.String
  @objc @_Concurrency.MainActor @preconcurrency public var subTitleNoti: Swift.String
  @objc @_Concurrency.MainActor @preconcurrency public var bodyNoti: Swift.String
  @objc @_Concurrency.MainActor @preconcurrency public var titleHeight: CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor @preconcurrency public var subtitleHeight: CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor @preconcurrency public var bodyHeight: CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor @preconcurrency public var viewHeight: CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor @preconcurrency public var topAnchorTitle: CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor @preconcurrency public var isContainActionButton: Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@_inheritsConvenienceInitializers @objc @_Concurrency.MainActor @preconcurrency public class RatingController : UIKit.UIViewController, UIKit.UIGestureRecognizerDelegate {
  @objc @_Concurrency.MainActor @preconcurrency public var data: Swift.String
  @objc @_Concurrency.MainActor @preconcurrency public var titleNoti: Swift.String
  @objc @_Concurrency.MainActor @preconcurrency public var subTitleNoti: Swift.String
  @objc @_Concurrency.MainActor @preconcurrency public var bodyNoti: Swift.String
  @objc @_Concurrency.MainActor @preconcurrency public var titleHeight: CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor @preconcurrency public var subtitleHeight: CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor @preconcurrency public var bodyHeight: CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor @preconcurrency public var viewHeight: CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@_inheritsConvenienceInitializers @objc @_Concurrency.MainActor @preconcurrency public class StyleBasicController : UIKit.UIViewController, UIKit.UIGestureRecognizerDelegate {
  @objc @_Concurrency.MainActor @preconcurrency public var data: Swift.String
  @objc @_Concurrency.MainActor @preconcurrency public var titleNoti: Swift.String
  @objc @_Concurrency.MainActor @preconcurrency public var subTitleNoti: Swift.String
  @objc @_Concurrency.MainActor @preconcurrency public var bodyNoti: Swift.String
  @objc @_Concurrency.MainActor @preconcurrency public var titleHeight: CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor @preconcurrency public var subtitleHeight: CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor @preconcurrency public var bodyHeight: CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor @preconcurrency public var viewHeight: CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor @preconcurrency public var isContainActionButton: Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@objc open class SocketIOClient : ObjectiveC.NSObject, SocketIOClientSpec {
  final public let nsp: Swift.String
  public var anyHandler: ((SocketAnyEvent) -> ())? {
    get
  }
  public var handlers: [SocketEventHandler] {
    get
  }
  weak public var manager: (any SocketManagerSpec)? {
    get
  }
  public var rawEmitView: SocketRawView {
    get
  }
  public var status: SocketIOStatus {
    get
  }
  public var sid: Swift.String? {
    get
  }
  public init(manager: any SocketManagerSpec, nsp: Swift.String)
  @objc deinit
  open func connect(withPayload payload: [Swift.String : Any]? = nil)
  open func connect(withPayload payload: [Swift.String : Any]? = nil, timeoutAfter: Swift.Double, withHandler handler: (() -> ())?)
  open func didConnect(toNamespace namespace: Swift.String, payload: [Swift.String : Any]?)
  open func didDisconnect(reason: Swift.String)
  open func disconnect()
  open func emit(_ event: Swift.String, _ items: any SocketData..., completion: (() -> ())? = nil)
  open func emit(_ event: Swift.String, with items: [any SocketData], completion: (() -> ())?)
  open func emitWithAck(_ event: Swift.String, _ items: any SocketData...) -> OnAckCallback
  open func emitWithAck(_ event: Swift.String, with items: [any SocketData]) -> OnAckCallback
  open func emitAck(_ ack: Swift.Int, with items: [Any])
  open func handleAck(_ ack: Swift.Int, data: [Any])
  open func handleClientEvent(_ event: SocketClientEvent, data: [Any])
  open func handleEvent(_ event: Swift.String, data: [Any], isInternalMessage: Swift.Bool, withAck ack: Swift.Int = -1)
  open func handlePacket(_ packet: SocketPacket)
  open func leaveNamespace()
  open func joinNamespace(withPayload payload: [Swift.String : Any]? = nil)
  open func off(clientEvent event: SocketClientEvent)
  open func off(_ event: Swift.String)
  open func off(id: Foundation.UUID)
  @discardableResult
  open func on(_ event: Swift.String, callback: @escaping NormalCallback) -> Foundation.UUID
  @discardableResult
  open func on(clientEvent event: SocketClientEvent, callback: @escaping NormalCallback) -> Foundation.UUID
  @discardableResult
  open func once(clientEvent event: SocketClientEvent, callback: @escaping NormalCallback) -> Foundation.UUID
  @discardableResult
  open func once(_ event: Swift.String, callback: @escaping NormalCallback) -> Foundation.UUID
  open func onAny(_ handler: @escaping (SocketAnyEvent) -> ())
  @available(*, unavailable, message: "Call the manager's reconnect method")
  open func reconnect()
  open func removeAllHandlers()
  open func setReconnecting(reason: Swift.String)
}
extension SocketClientEvent : Swift.Equatable {}
extension SocketClientEvent : Swift.Hashable {}
extension SocketClientEvent : Swift.RawRepresentable {}
extension SocketAckStatus : Swift.Equatable {}
extension SocketAckStatus : Swift.Hashable {}
extension SocketAckStatus : Swift.RawRepresentable {}
extension CloseCode : Swift.Equatable {}
extension CloseCode : Swift.Hashable {}
extension CloseCode : Swift.RawRepresentable {}
extension FrameOpCode : Swift.Equatable {}
extension FrameOpCode : Swift.Hashable {}
extension FrameOpCode : Swift.RawRepresentable {}
extension FoundationSecurityError : Swift.Equatable {}
extension FoundationSecurityError : Swift.Hashable {}
extension SocketParsableError : Swift.Equatable {}
extension SocketParsableError : Swift.Hashable {}
extension Signature.DigestType : Swift.Equatable {}
extension Signature.DigestType : Swift.Hashable {}
extension _objc_Signature.DigestType : Swift.Equatable {}
extension _objc_Signature.DigestType : Swift.Hashable {}
extension _objc_Signature.DigestType : Swift.RawRepresentable {}
extension TCPTransportError : Swift.Equatable {}
extension TCPTransportError : Swift.Hashable {}
extension ModifyAction : Swift.Equatable {}
extension ModifyAction : Swift.Hashable {}
extension ModifyAction : Swift.RawRepresentable {}
extension SecurityErrorCode : Swift.Equatable {}
extension SecurityErrorCode : Swift.Hashable {}
extension SecurityErrorCode : Swift.RawRepresentable {}
extension ErrorType : Swift.Equatable {}
extension ErrorType : Swift.Hashable {}
extension SocketIOStatus : Swift.Equatable {}
extension SocketIOStatus : Swift.Hashable {}
extension SocketIOStatus : Swift.RawRepresentable {}
extension SocketEnginePacketType : Swift.Equatable {}
extension SocketEnginePacketType : Swift.Hashable {}
extension SocketEnginePacketType : Swift.RawRepresentable {}
extension SocketPacket.PacketType : Swift.Equatable {}
extension SocketPacket.PacketType : Swift.Hashable {}
extension SocketPacket.PacketType : Swift.RawRepresentable {}
extension FoundationTransportError : Swift.Equatable {}
extension FoundationTransportError : Swift.Hashable {}
extension SocketIOVersion : Swift.Equatable {}
extension SocketIOVersion : Swift.Hashable {}
extension SocketIOVersion : Swift.RawRepresentable {}
extension SocketIOClientOption : Swift.Equatable {}
extension SocketIOClientOption : Swift.CustomStringConvertible {}
